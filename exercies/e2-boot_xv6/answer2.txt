Breakpoint 1, 0x0010000c in ?? ()
(gdb) info reg
eax            0x0      0
ecx            0x0      0
edx            0x1f0    496
ebx            0x10054  65620
esp            0x7bcc   0x7bcc
ebp            0x7bf8   0x7bf8
esi            0x100000 1048576
edi            0x11513c 1134908
eip            0x10000c 0x10000c
eflags         0x46     [ PF ZF ]
cs             0x8      8
ss             0x10     16
ds             0x10     16
es             0x10     16
fs             0x0      0
gs             0x0      0
(gdb) x/24x $esp
0x7bcc: 0x00007da5      0x00000000      0x00000000      0x00000000
0x7bdc: 0x00010054      0x00000000      0x00000000      0x00000000
0x7bec: 0x00000000      0x00000000      0x00000000      0x00000000
0x7bfc: 0x00007c4d      0x8ec031fa      0x8ec08ed8      0xa864e4d0
0x7c0c: 0xb0fa7502      0xe464e6d1      0x7502a864      0xe6dfb0fa
0x7c1c: 0x16010f60      0x200f7c78      0xc88366c0      0xc0220f01

(gdb) x/24x 0x7bc0
0x7bc0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7bd0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7be0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7bf0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7c00: 0x8ec031fa      0x8ec08ed8      0xa864e4d0      0xb0fa7502
0x7c10: 0xe464e6d1      0x7502a864      0xe6dfb0fa      0x16010f60

after processing the stack
(gdb) x/24x 0x7bc0
0x7bc0: 0x00007d3f      0x00010000      0x00001000      0x00000000
0x7bd0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7be0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7bf0: 0x00000000      0x00000000      0x00000000      0x00007c4d
0x7c00: 0x8ec031fa      0x8ec08ed8      0xa864e4d0      0xb0fa7502
0x7c10: 0xe464e6d1      0x7502a864      0xe6dfb0fa      0x16010f60


Q & A
1. Start by setting a break-point at 0x7c00, the start of the boot block (bootasm.S). Single step through the instructions (type si to the gdb prompt). Where in bootasm.S is the stack pointer initialized?
Ans: move the stack pointer $esp to $start (0x7c00)
movl 0x7c00, %esp

2. Single step through the call to bootmain; what is on the stack now?
(gdb) x/24x 0x7bc0
0x7bc0: 0x00007d3f      0x00010000      0x00001000      0x00000000
0x7bd0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7be0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7bf0: 0x00000000      0x00000000      0x00000000      0x00007c4d
0x7c00: 0x8ec031fa      0x8ec08ed8      0xa864e4d0      0xb0fa7502
0x7c10: 0xe464e6d1      0x7502a864      0xe6dfb0fa      0x16010f60

3. What do the first assembly instructions of bootmain do to the stack? Look for bootmain in bootblock.asm.
Ans: push %ebp

4. Look in bootmain in bootblock.asm for the call that changes eip to 0x10000c. What does that call do to the stack?

Summary
At the beginning, it does not use segment register - in 8088 mode

stack frame
0x7c00 |      				movl $start, $esp
0x7bfc | 0x7c4d (ret addr)	call 0x7d25
0x7bf8 | 0x0 (old %ebp)		pushl %ebp; movl %esp, %ebp
0x7bf4 | 0x0 (old %edi)		pushl %edi
0x7bf0 | 0x0 (old %esi) 	pushl %esi	
0x7bec | 0x0 (old %ebx)		pushl %ebx
0x7be8 | 					sub $0x1c, %esp
...
...
0x7bd0 | 					<- %esp
0x7bcc | 0x0				pushl $0x0
0x7bc8 | 0x1000				pushl $0x1000
0x7bc4 | 0x10000			pushl $0x10000
0x7bc0 | 0x7d3f (ret addr)	call 0x7ce6


